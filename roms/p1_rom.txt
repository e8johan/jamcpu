P1:	JUMP	R30, R0, INIT	-- Call init subroutine, link in R30 (=P1+4)
0
0111 11 11110 00000 0000 0000 0000 1110

	ADDI	R1, R0, 12		-- R1 = 12, index counter
4	
0000 01 00001 00000 0000 0000 0000 1100
	
	ADDI	R4, R0, R0		-- R4 = 0, accumulator
8	
0000 00 00100 00000 00000
	
L1:	LW		R2, R1, 1024	-- Read from array at address 1024
12
1000 11 00010 00001 0000 0001 0000 0000

	LW		R3, R1, 1040	-- Read from array at address 1040
16
1000 11 00011 00001 0000 0001 0000 0100

	MUL		R5, R2, R3		-- Multiply array elements
20
0010 00 00101 00010 00011
	
	ADDI	R1, R1, -4		-- Compute next index
24	
0000 01 00001 00001 1111 1111 1111 1100
	
	ADD		R4, R4, R5		-- Add product to accumulator
28	
0000 00 00100 00100 00101
	
	CMP		R5, R0, R1		-- Check if next index < 0
32	
0110 00 00101 00000 00001
	
	BNE		R5, R0, -28		-- Branch to L1 if next index ³ 0
36	
0101 11 00101 00000 1111 1111 1111 1010

	NOP
40	
0000 0000 0000 0000 0000 0000 0000 0000
	
	SW		R4, R0, 1056	-- Store accumulated result at address 1056
44	
1001 11 00100 00000 0000 0001 0000 1000
	
END:BEQ		R0, R0, 0		-- End program with infinite loop
48
0100 11 00000 00000 0000 0000 0000 0000

	NOP
52	
0000 0000 0000 0000 0000 0000 0000 0000

INIT:
	ADDI	R1, R0, 32		-- Prepare initialization of arrays
56	
0000 01 00001 00000 0000 0000 0010 0000
	
L2:	SW		R1, R1, 1020	-- Store array element
60
1001 11 00001 00001 0000 0000 1111 1111

	ADDI	R1, R1, -4		-- Next index
64
0000 01 00001 00001 1111 1111 1111 1100
	
	BNE		R1, R0, -12		-- If not finished, loop to L2
68	
0101 11 00001 00000 1111 1111 1111 1110

	NOP
72	
0000 0000 0000 0000 0000 0000 0000 0000

	JUMP	R0, R30, 1		-- Return to address in link register R30
76
0111 11 00000 11110 0000 0000 0000 0001

	NOP
80	
0000 0000 0000 0000 0000 0000 0000 0000	

	NOP
84	
0000 0000 0000 0000 0000 0000 0000 0000	

	NOP
88	
0000 0000 0000 0000 0000 0000 0000 0000	

	NOP
92	
0000 0000 0000 0000 0000 0000 0000 0000	

